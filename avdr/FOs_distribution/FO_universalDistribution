distribution
{
  libs (utilityFunctionObjects);
  type coded;
  name computeDistribution;
    
  executeControl    timeStep;
  executeInterval   1000;
  writeControl      timeStep;
  writeInterval     1000;
  
  codeOptions
  #{
	  -I$(LIB_SRC)/finiteVolume/lnInclude \
	  -I$(LIB_SRC)/meshTools/lnInclude \
  #};
  codeInclude
  #{
    #include "wallDist.H"
  #};
  codeData
  #{
    const scalar ratioSpecHeats  = 1.4;
    const scalar isenTotPressure = 1.0e5;
    /*
    // schreiber 84
    // - geometry
    //   - angles: these are connected, see documentation
    const scalar betas     = degToRad(138.51);
    const scalar gamma_c   = Foam::constant::mathematical::pi - betas ;
    const scalar gamma     = betas - Foam::constant::mathematical::pi/2;

    //   - lengths 
    const scalar trueChord  = 0.09;
    const scalar pitch      = trueChord*0.621; // not neccessarily, property of the DLR cascade

    const scalar axialChord = trueChord*sin(gamma_c);
    */

    // kobra
    // - geometry
    //   - angles: these are connected, see documentation
    const scalar betas     = Foam::constant::mathematical::pi/2;
    const scalar gamma_c   = Foam::constant::mathematical::pi/2;
    const scalar gamma     =      0;

    //   - lengths 
    const scalar trueChord  = 0.100;
    const scalar pitch      = 0.075; // not neccessarily, property of the DLR cascade

    const scalar axialChord = trueChord*sin(gamma_c);

    // - distribution
    const int    typeDf   = 1;
    const scalar a        = -0.25;
    const scalar b        =  1.25;
    const scalar c        =  1e-3; // minimum distance from the wall for non zero fluxes

    const scalar dist_min = a*axialChord;
    const scalar dist_max = b*axialChord;   
  #};
  codeWrite
  #{
      const volVectorField& cCenters = mesh().C(); 
      volScalarField distribution
      (
        IOobject
      (
        "distribution",
        "constant",
        mesh(),
        IOobject::NO_READ,
        IOobject::AUTO_WRITE
      ),
        mesh(),
        dimensionedScalar("distribution", dimless, 0.0)
      );

      volScalarField wallDistance
      (
        IOobject
      (
        "wallDistance",
        mesh().time().timeName(),
        mesh(),
        IOobject::NO_READ,
        IOobject::AUTO_WRITE
      ),
        mesh(),
        dimensionedScalar("wallDistance", dimensionSet(0,1,0,0,0,0,0), 0)
      );

      wallDistance = wallDist(mesh()).y();

      forAll(cCenters, cellI)
      {
        scalar x = cCenters[cellI][0];
        scalar y = cCenters[cellI][1];
        // rotate from x,y to ax,tan (= x_ax, y_ax)
        scalar x_ax = cos(gamma) * x + sin(gamma) * y;

        if (   x_ax >= dist_min && x_ax <= dist_max && wallDistance[cellI] > 1e-3 ) 
        {
          switch(typeDf) {
          case 1:
            distribution[cellI] =  1.0;
            break;
          case 2: {
            const volScalarField& p_case2 = mesh().lookupObject<volScalarField>("p");
            if ( p_case2[cellI] > isenTotPressure *pow(2/(1+ratioSpecHeats), ratioSpecHeats/(ratioSpecHeats-1)) ){
              distribution[cellI] =  1.0;
            }
            break;
            }
          case 3:{
            const volScalarField& p = mesh().lookupObject<volScalarField>("p");
            volScalarField::Boundary& pb = const_cast<volScalarField*>(&p)->boundaryFieldRef();
  
            label inletId = mesh().boundaryMesh().findPatchID("inlet");
            label outletId = mesh().boundaryMesh().findPatchID("outlet");
            
            const scalarField& magSfIn  = mesh().magSf().boundaryField()[ inletId];
            const scalarField& magSfOut = mesh().magSf().boundaryField()[outletId];
  
            const scalar p1 = gSum(pb[ inletId]*magSfIn )/gSum(magSfIn );
            const scalar p2 = gSum(pb[outletId]*magSfOut)/gSum(magSfOut);
            distribution[cellI] =  (p[cellI] - p1)/(p2-p1);
            break;
            }
          }         
        }
      }
      distribution.write();
      Info << "Distribution was computed and written." << endl;
  #};
}